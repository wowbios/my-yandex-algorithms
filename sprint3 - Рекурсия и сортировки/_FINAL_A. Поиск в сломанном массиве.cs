/*
Алла ошиблась при копировании из одной структуры данных в другую. Она хранила массив чисел в кольцевом буфере. Массив был отсортирован по возрастанию, и в нём можно было найти элемент за логарифмическое время. Алла скопировала данные из кольцевого буфера в обычный массив, но сдвинула данные исходной отсортированной последовательности (при этом массив все равно мог остаться отсортированным).

Тем не менее, нужно обеспечить возможность находить в нем элемент за O(logn).

Можно предполагать, что в массиве только уникальные элементы.

От вас требуется реализовать функцию, осуществляющую поиск в сломанном массиве. Обратите внимание, что считывать данные и выводить ответ не требуется. 
*/

/*
-- ПРИНЦИП РАБОТЫ --
Воспользуемся принципом бинарного поиска, т.к. он подходит нам по требуемой сложности O(log N). Но слегка модифицируем его с учётом наличия "перепада".
Таким образом, поиск ведется согласно алгоритму бинарного поиска, но при определении "перепада" в рассматриваемом диапазоне производится доп. анализ этого диапазона на факт наличия там искомого элемента.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Оригинальный алгоритм бинарного поиска предназначен для поиска в отсортированной последовательности. В нашем случае массив не обязательно отсортирован: в одном из внутренних интервалов есть вероятность наткнуться на "перепад", исходя из постановки задачи.
Отличительной особенность оригинального алгоритма бинарного поиска является постоянное сужение диапазона поиска - это позволяет сразу отсеять диапазоны без нужного элемента. Этот вывод делается на каждой итерации, на основе сравнения одного элемента из диапазона с искомым значением. Этот сравниваемый элемент, в общем случае, берётся из середины диапазона. 
Т.е. при интервале [left;right) проверяем условие left <= element < right

В нашем случае, в одной из итераций может попасться диапазон другого характера, в котором есть "перепад". Его легко определить сравнением левой и правой границы диапазона. Если элемент слева больше элемента справа, то в этом диапазоне есть "перепад".
Остаётся понять, есть ли там искомый элемент. Такой диапазон можно описать как [left .. min .. right),
где left - левый элемент диапазона, right - правый элемент диапазона и min - минимально возможное значение во всей последовательности (т.н. "перепад"). При этом left > right > min и left >= min. В некоторых случаях min и right могут быть равны, если в кач-ве правой границы мы веберем минимально возможный элемент.
Чтобы понять, есть ли там наш элемент, достаточно проверить, входит ли он в один из подинтервалов [left;min) или [min;right).

|LEFT-----MIN-----RIGHT|
|LEFT--X--MIN-----RIGHT| - если X > LEFT и X > RIGHT
|LEFT-----MIN--X--RIGHT| - если X < LEFT и X < RIGHT

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Сложность алгоритма однозначно сопоставима со сложностью бинарного поиска O(log N), т.к. в задаче мы используем лишь измененную проверку вхождения искомого элемента в диапазон. Сама проверка константна и занимает O(1), поэтому её можно не учитывать.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Пространственную сложность достаточно оценить глубиной рекурсии, т.к. использован рекурсивный алгоритм бинарного поиска. Сложность по рекурсии будет O(log N) - совпадать со сложностью алгоритма, т.к. на каждый диапазон поиска в стеке будет сохранено состояние рекурсивного метода.

*/

using System;
using System.Collections.Generic;

public class Solution
{
    public static int BrokenSearch(List<int> array, int element)
    {
        const int NotFound = -1;

        int? index = FindElementIndex(array, element, 0, array.Count);
        return index ?? NotFound;
    }

    private static int? FindElementIndex(
        List<int> array,
        int element,
        int from,
        int to)
    {
        int mid = (from + to) / 2;
        if (array[mid] == element)
            return mid;

        if (to - from is 1)
            return null;
            
        int left = array[from];
        int right = array[to - 1];
        if (InBreakingRange(element, left, right) || InGrowingRange(element, left, right))
            return FindElementIndex(array, element, from, mid)
                ?? FindElementIndex(array, element, mid, to);

        return null;
    }

    private static bool InBreakingRange(int element, int start, int end)
            => start > end
            &&
            (
                (start <= element && end <= element)
                ||
                (start >= element && end >= element)
            );

    private static bool InGrowingRange(int element, int start, int end)
        => start < end && start <= element && element <= end;

#if !REMOTE_JUDGE
    public static void M()
    {
        var arr = new List<int> { 1 };
        Console.WriteLine(BrokenSearch(arr, 1) == 1);
    }
#endif
}