/*
Тимофей решил организовать соревнование по спортивному программированию, чтобы найти талантливых стажёров. Задачи подобраны, участники зарегистрированы, тесты написаны. Осталось придумать, как в конце соревнования будет определяться победитель.

Каждый участник имеет уникальный логин. Когда соревнование закончится, к нему будут привязаны два показателя: количество решённых задач Pi и размер штрафа Fi. Штраф начисляется за неудачные попытки и время, затраченное на задачу.

Тимофей решил сортировать таблицу результатов следующим образом: при сравнении двух участников выше будет идти тот, у которого решено больше задач. При равенстве числа решённых задач первым идёт участник с меньшим штрафом. Если же и штрафы совпадают, то первым будет тот, у которого логин идёт раньше в алфавитном (лексикографическом) порядке.

Тимофей заказал толстовки для победителей и накануне поехал за ними в магазин. В своё отсутствие он поручил вам реализовать алгоритм быстрой сортировки (англ. quick sort) для таблицы результатов. Так как Тимофей любит спортивное программирование и не любит зря расходовать оперативную память, то ваша реализация сортировки не может потреблять O(n) дополнительной памяти для промежуточных данных (такая модификация быстрой сортировки называется "in-place").

Как работает in-place quick sort
Как и в случае обычной быстрой сортировки, которая использует дополнительную память, необходимо выбрать опорный элемент (англ. pivot), а затем переупорядочить массив. Сделаем так, чтобы сначала шли элементы, не превосходящие опорного, а затем —– большие опорного.

Затем сортировка вызывается рекурсивно для двух полученных частей. Именно на этапе разделения элементов на группы в обычном алгоритме используется дополнительная память. Теперь разберёмся, как реализовать этот шаг in-place.

Пусть мы как-то выбрали опорный элемент. Заведём два указателя left и right, которые изначально будут указывать на левый и правый концы отрезка соответственно. Затем будем двигать левый указатель вправо до тех пор, пока он указывает на элемент, меньший опорного. Аналогично двигаем правый указатель влево, пока он стоит на элементе, превосходящем опорный. В итоге окажется, что что левее от left все элементы точно принадлежат первой группе, а правее от right — второй. Элементы, на которых стоят указатели, нарушают порядок. Поменяем их местами (в большинстве языков программирования используется функция swap()) и продвинем указатели на следующие элементы. Будем повторять это действие до тех пор, пока left и right не столкнутся.
На рисунке представлен пример разделения при pivot=5. Указатель left — голубой, right — оранжевый.
Формат ввода

В первой строке задано число участников n, 1 ≤ n ≤ 100 000.
В каждой из следующих n строк задана информация про одного из участников.
i-й участник описывается тремя параметрами:

    уникальным логином (строкой из маленьких латинских букв длиной не более 20)
    числом решённых задач Pi
    штрафом Fi

Fi и Pi — целые числа, лежащие в диапазоне от 0 до 109.

Формат вывода

Для отсортированного списка участников выведите по порядку их логины по одному в строке.
*/

/*
-- ПРИНЦИП РАБОТЫ --
Массив с информацией об участниках обрабатывается с помощью in-place quick sort алгоритма с двумя особенностями:
- сортировка осуществляется по невозрастанию
- pivot выбирается случайны образом

Информация об участниках представлена в виде readonly record struct Competitor - т.к. представляет собой конечный набор иммутабельных простых значений. Для корректного сравнения участников реализован метод Competitor.CompareTo.

Так же можно было бы оставить каноничный алгоритм сортировки (по неубыванию), но поменять алгоритм сравнения инвертировав его результат.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
В качестве решения выбран алгоритм сортировки in-place quick sort. Выбранный алгоритм, хоть и является нестабильным (из-за выбранной схемы разбиения Хоара), но подходит нам из-за его средней сложности O(N * log N).

Допустим у нас есть некоторый набор данных
[ .. ]

Алгоритм начинается с выбора опорного элемента (pivot). В качестве pivot элемента выбирается случайный элемент, т.к. на практике, при таком разбиении, вероятность получить на входе killer-sequence алгоритма - ниже. (killer-sequence - последовательность, которая будет худшим случаем для алгоритма).
[ .. pivot .. ]

Затем начинаем идти двумя указателями слева и справа в сторону центра. Когда оба указателя указывают на элементы, которые должен быть с другой стороны от pivot (для левого указателя - справа, для правого указателя - слева), осуществляется обмен значений в массиве по указателям.
[left .. pivot .. right]

Как только указатели пересекутся, т.е. пройдут мимо друг друга, мы останавливаем алгоритм.
[.. right pivot left ..]

На данном этапе, элемент pivot стоит на своём конечном месте. Слева от него - элементы большие его, справа - меньшие (я реализовал сортировку по невозрастанию). Далее достаточно рекурсивно применить данный алгоритм к левой и правой части (! больше не смотрим элемент pivot, т.к. он стоит на своём месте). Базовый случай рекурсии при этом, когда right >= left. Тогда не имеет смысла сортировать дальше, т.к. мы пытаемся отсортировать пустой диапазон или диапазон из 1 элемента.
[ .. right] [ left .. ]

В конечном итоге массив будет отсортирован.

Доказательство корректности алгоритма сравнения:
Для базовых типов в .NET реализован интерфейс IComparable и метод CompareTo. Его результат может быть:
-1 - рассматриваемый элемент меньше сравниваемого
0 - рассматриваемый и сравниваемый элементы - равны
1 - рассматриваемый элемент больше сравниваемого

Для реализации корректного сравнения участников реализован метод IComparable<Competitor>.CompareTo. Он, как и CompareTo для базовых типов, возвращает результат сравнения.

Сначала мы сравниваем кол-во решенных задач. Если результат не 0 (не равны), то возвращаем его, т.к. он сразу показывает какой элемент Competitor "больше".
Если кол-во решенных задач одинаковое, то идём дальше по алгоритму.
Далее мы рассматриваем кол-во штрафных очков. Если результат не 0 (не равны), то возвращаем его, предварительно инвертировав, т.к. выше будет указан тот участник, у кого меньше штрафных очков.
Если кол-во штрафных очков одинаковое, то идём дальше по алгоритму.
Возвращаем результат лексикографического сравнения имён.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Рассмотрим работу на одном уровне рекурсии.
Выбор pivot - в общем случае O(1), т.к. это генерация случайного числа в известном диапазоне. В данном случае она может зависеть от реализации алгоритма выбора случайного числа.
Алгоритм с указателями займёт 
O(N + 1(движение left на pivot) + 1(движение left за pivot) + 1(движение right за pivot) + 1(движение right на pivot))
 = O(N + 4)
 = O(N), т.к. указатели будут "бежать" навстречу друг другу с обоих концов и закончат движение на следующий шаг, после пересечения на pivot элементе.
На каждой из глубин рекурсии, данный алгоритм будет применен к частям массива, которые в итоге образуют оригинальный массив. Поэтому можно считать, что в лучшем случае сложность будет O(кол-во операций с элементами * кол-во уровней рекурсии) = O(N * log N).

Стоит заметить, что она зависит от способа разбиения массива и от способа выбора pivot.
Например, если мы будем выбирать pivot как "всегда последний элемент", то на каждом этапе рекурсии будет произведена одна замена (с pivot элементом). Тогда, в худшем случае, сложность будет O(N^2).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Для выбранной in-place реализации сложность по памяти будет O(1), т.к. мы не используем доп. память для хранения наборов данных при реализации.
С учётом реализации через рекурсию, стоит заметить, чтобы будут расходы памяти в зависимости от глубины рекурсии. Тогда можно сказать, что в лучшем случае O(кол-во уровней рекурсии) = O(log N). В худшем случае O(N^2), напр. при выборе pivot как последнего элемента.

Используемые материалы:
https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme
https://ru.wikipedia.org/wiki/%D0%91%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0
https://www.youtube.com/watch?v=maibrCbZWKw
https://www.youtube.com/watch?v=WprjBK0p6rw
https://www.youtube.com/watch?v=pM-6r5xsNEY
*/

using System;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Threading;

public readonly record struct Competitor(string Name, int Solved, int Penalty) : IComparable<Competitor>
{
    public int CompareTo(Competitor other)
    {
        int compareResult = Solved.CompareTo(other.Solved);
        if (compareResult != 0)
            return compareResult;

        compareResult = Penalty.CompareTo(other.Penalty);
        if (compareResult != 0)
            return -compareResult;
        
        return string.Compare(other.Name, Name);
    }

    public static bool operator >(Competitor first, Competitor second)
        => first.CompareTo(second) > 0;

    public static bool operator <(Competitor first, Competitor second)
        => first.CompareTo(second) < 0;
}

public class Program : IDisposable
{
    private readonly StreamReader _reader;
    private readonly StreamWriter _writer;

    public Program()
    {
        _reader = new StreamReader(Console.OpenStandardInput());
        _writer = new StreamWriter(Console.OpenStandardOutput());
    }

    public void Run()
    {
        Competitor[] competitors = ReadInput();

        InPlaceQuickSort(competitors, 0, competitors.Length - 1);

        foreach (Competitor competitor in competitors)
            _writer.WriteLine(competitor.Name);
    }

    private static void InPlaceQuickSort(Competitor[] mans, int from, int to)
    {
        if (from == to)
            return;

        int mid = Random.Shared.Next(from, to + 1);
        Competitor pivot = mans[mid];

        int left = from, right = to;
        do
        {
            while (mans[left] > pivot)
                left++;
            while (mans[right] < pivot)
                right--;

            if (right < left) // crossed
                break;
            
            // swap
            (mans[left], mans[right]) = (mans[right], mans[left]);

            // move next
            left++;
            right--;
        }
        while(right >= from && left <= to);

        InPlaceQuickSort(mans, from, right);
        InPlaceQuickSort(mans, left, to);
    }

    private Competitor[] ReadInput()
    {
        int count = int.Parse(_reader.ReadLine()!);
        var competitors = new Competitor[count];
        for (int i = 0; i < count; i++)
        {
            string[] values = _reader.ReadLine()!.Split(' ').ToArray();
            competitors[i] = new Competitor(
                    values[0],
                    int.Parse(values[1]),
                    int.Parse(values[2]));
        }

        return competitors;
    }

    public void Dispose()
    {
        _reader.Dispose();
        _writer.Flush();
        _writer.Dispose();
    }

    public static void Main()
    {
        Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;

        using var program = new Program();
        program.Run();
    }
}
